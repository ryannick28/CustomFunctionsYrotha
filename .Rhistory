### Add stars:
sigStr <- c('', '*', '**', '***')
sigThr <- c(1.1, 0.05, 0.01, 0.001)   # 1.1 in case pvalue is rounded to 1 (difference in next line has to be negative at least once)
if(multCmp){
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP_bonf < 0.05,]
### Get stars according to bonferroni corrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP_bonf'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}else{
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP < 0.05,]
### Get stars according to uncorrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}
### Add y-values for plot (should not be too far apart):
grCmp$yVal <- max(ylms) + (abs(min(ylms)-max(ylms))*0.05 * 1:nrow(grCmp))
### Adapt ylms:
ylms <- c(ylms[1], ifelse(is.null(ylim.cust), yes = max(grCmp$yVal), no = ylms[2]))
### Draw lines:
for(i in 1:nrow(grCmp)){
lines(x = grCmp[i,1:2], y = rep(grCmp[i,'yVal'], 2))
}
#**********************
### Run group comparisons:
if(nlevels(catVar) > 1 & sigTest){   # Only run if catVar has entries of multiple levels
### List group comparisons in table:
grInd <- data.frame(t(combn(1:nlevels(catVar),2)))
### Apply wilcoxon tests to compare corresponding groups (collect pvalues):
wilxP <- apply(grInd, 1, function(x){ wilcox.test(x = numVar[as.numeric(catVar)==x[1]],
y = numVar[as.numeric(catVar)==x[2]])$p.value })
### Combine to table (add bonferonni corrected pvals and y values in plot):
grCmp.0 <- cbind(grInd, wilxP, 'wilxP_bonf'=wilxP*nrow(grInd))
### Add stars:
sigStr <- c('', '*', '**', '***')
sigThr <- c(1.1, 0.05, 0.01, 0.001)   # 1.1 in case pvalue is rounded to 1 (difference in next line has to be negative at least once)
if(multCmp){
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP_bonf < 0.05,]
### Get stars according to bonferroni corrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP_bonf'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}else{
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP < 0.05,]
### Get stars according to uncorrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}
### Add y-values for plot (should not be too far apart):
grCmp$yVal <- max(ylms) + (abs(min(ylms)-max(ylms))*0.05 * 1:nrow(grCmp))
### Adapt ylms:
ylms <- c(ylms[1], ifelse(is.null(ylim.cust), yes = max(grCmp$yVal), no = ylms[2]))
}
#**********************
### Get title name:
main.nm <- deparse(substitute(main))
### Start plot:
plot(x = jitter(as.numeric(catVar), factor = jitFactor),
y = numVar,
xlim = c(0,nlevels(catVar)+1),
ylim = ylms,
xaxt = 'n',
col = catVar,
ylab = deparse(substitute(numVar)),
xlab = ifelse(catVar.nm=='NULL', '', catVar.nm),
main = ifelse(main.nm=='NULL', paste0(deparse(substitute(numVar)), ' Plot'), main))
deparse(substitute(numVar))
ifelse(main.nm=='NULL', paste0(deparse(substitute(numVar)), ' Plot'), main)
paste0(deparse(substitute(numVar))
)
main
main.nm
### Start plot:
plot(x = jitter(as.numeric(catVar), factor = jitFactor),
y = numVar,
xlim = c(0,nlevels(catVar)+1),
ylim = ylms,
xaxt = 'n',
col = catVar,
ylab = deparse(substitute(numVar)),
xlab = ifelse(catVar.nm=='NULL', '', catVar.nm),
main = ifelse(main.nm=='NULL', paste0(deparse(substitute(numVar)), ' Plot'), main))
### Start plot:
plot(x = jitter(as.numeric(catVar), factor = jitFactor),
y = numVar,
xlim = c(0,nlevels(catVar)+1),
ylim = ylms,
xaxt = 'n',
col = catVar,
ylab = deparse(substitute(numVar)),
xlab = ifelse(catVar.nm=='NULL', '', catVar.nm),
main = 'test')
### Add legend:
if(nlevels(catVar) > 1){   # Only needed with multiple levels
legend('bottomright', legend = levels(catVar),
pch=1,
col=1:nlevels(catVar))
}
### Add the violin lines:
if(violin){
L <- list()
for(i in 1:nlevels(catVar)){
d <- density(numVar[as.numeric(catVar)==i], na.rm = TRUE, bw = bw)
L[[i]] <- data.frame(xd=d$x, yd=d$y)
}
names(L) <- levels(catVar)
### We have to scale the densities, need the maximum value for that:
maxD <-  max(sapply(L, function(x){x$yd}))
cexD <- densScl/maxD
### Now plot the densities:
for(i in 1:nlevels(catVar)){
lines(L[[i]]$yd*cexD + i, L[[i]]$xd, col=i)
lines((-L[[i]]$yd)*cexD + i, L[[i]]$xd, col=i)
}
}
### Add the mean-value lines:
if(showMean){
for(i in 1:nlevels(catVar)){
mVal <-  mean(numVar[as.numeric(catVar)==i], na.rm = TRUE)
segments(x0 = i-0.3, y0 = mVal, x1 = i+0.3, y1 = mVal, col = i, lwd = 2)
}
}
i
i <- 1
nlevels(catVar) > 1 & sigTest
lines(x = grCmp[i,1:2], y = rep(grCmp[i,'yVal'], 2))
lines(x = grCmp[i,1:2], y = rep(grCmp[i,'yVal'], 2))
grCmp[i,1:2]
xx <- grCmp[i,1:2]
xx
yy <- rep(grCmp[i,'yVal'], 2)
lines(x = xx, y = yy)
lines(xx, yy)
lines(c(xx[1], xx[1]), c(yy[1], yy[1]-0.01))
lines(c(xx[1], xx[1]), c(yy[1], yy[1]-0.1))
lines(c(xx[2], xx[2]), c(yy[2], yy[2]-0.1))
par('usr')
(abs(min(ylms)-max(ylms))*0.05
)
### Find a good ticklength:
tickL <- (abs(min(ylms)-max(ylms))*0.01)
tickL
lines(c(xx[1], xx[1]), c(yy[1], yy[1] - tickL))
lines(c(xx[2], xx[2]), c(yy[2], yy[2] - tickL))
i <- 2
xx <- grCmp[i,1:2]
yy <- rep(grCmp[i,'yVal'], 2)
lines(xx, yy)
### Find a good ticklength:
tickL <- (abs(min(ylms)-max(ylms))*0.01)
lines(c(xx[1], xx[1]), c(yy[1], yy[1] - tickL))
lines(c(xx[2], xx[2]), c(yy[2], yy[2] - tickL))
sigStr
grCmp
mean(xx)
xx
mean(xx)
xx
mean(as.vector(xx))
mean(as.numeric(xx))
xx <- as.numeric(grCmp[i,1:2])
yy <- rep(grCmp[i,'yVal'], 2)
xx
yy
str(xx)
str(yy)
### Add star:
text(x = mean(xx), y = yy[1]+tickL)
grCmp
### Add star:
text(x = mean(xx), y = yy[1]+tickL, labels = grCmp[i,'yVal'])
### Add star:
text(x = mean(xx), y = yy[1]+tickL, labels = grCmp[i,'strs'])
i <- 3
xx <- as.numeric(grCmp[i,1:2])
yy <- rep(grCmp[i,'yVal'], 2)
lines(xx, yy)
### Find a good ticklength:
tickL <- (abs(min(ylms)-max(ylms))*0.01)
lines(c(xx[1], xx[1]), c(yy[1], yy[1] - tickL))
lines(c(xx[2], xx[2]), c(yy[2], yy[2] - tickL))
### Add star:
text(x = mean(xx), y = yy[1]+tickL, labels = grCmp[i,'strs'])
#*********************************************************************************
#   NICE UNIVARIATE PLOT   ####
#*********************************************************************************
niceUnivPlot <- function(numVar, catVar=NULL, violin=TRUE, showMean=TRUE,
bw='nrd0', jitFactor=0.2, add.ylim=0, ylim.cust=NULL,
densScl=0.5, main=NULL, multCmp=FALSE, sigTest=TRUE){
### Check some requirements:
stopifnot(is.numeric(numVar))
stopifnot(is.null(ylim.cust) | length(ylim.cust)==2)   # Check valid entries for ylim.cust
### Set ylim:
if(is.null(ylim.cust)){
ylms <- c(min(numVar, na.rm = TRUE), max(numVar, na.rm = TRUE))
}else{   # Custom ylim
ylms <- ylim.cust
}
ylms <- ylms + c(-add.ylim, add.ylim)   # Add the add.ylim
### Generate catvar:
catVar.nm <- deparse(substitute(catVar))   # Get name of catVar
if(is.null(catVar)){
catVar <- factor(rep(1,length(numVar)))   # 1-level factor
}else{
catVar <- factor(catVar)   # Dont use as.factor, otherwise non-present levels are not removed.
}
#**********************
### Run group comparisons:
if(nlevels(catVar) > 1 & sigTest){   # Only run if catVar has entries of multiple levels
### List group comparisons in table:
grInd <- data.frame(t(combn(1:nlevels(catVar),2)))
### Apply wilcoxon tests to compare corresponding groups (collect pvalues):
wilxP <- apply(grInd, 1, function(x){ wilcox.test(x = numVar[as.numeric(catVar)==x[1]],
y = numVar[as.numeric(catVar)==x[2]])$p.value })
### Combine to table (add bonferonni corrected pvals and y values in plot):
grCmp.0 <- cbind(grInd, wilxP, 'wilxP_bonf'=wilxP*nrow(grInd))
### Add stars:
sigStr <- c('', '*', '**', '***')
sigThr <- c(1.1, 0.05, 0.01, 0.001)   # 1.1 in case pvalue is rounded to 1 (difference in next line has to be negative at least once)
if(multCmp){
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP_bonf < 0.05,]
### Get stars according to bonferroni corrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP_bonf'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}else{
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP < 0.05,]
### Get stars according to uncorrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}
### Add y-values for plot (should not be too far apart):
grCmp$yVal <- max(ylms) + (abs(min(ylms)-max(ylms))*0.05 * 1:nrow(grCmp))
### Adapt ylms:
ylms <- c(ylms[1], ifelse(is.null(ylim.cust), yes = max(grCmp$yVal), no = ylms[2]))
}
#**********************
### Get title name:
main.nm <- deparse(substitute(main))
### Start plot:
plot(x = jitter(as.numeric(catVar), factor = jitFactor),
y = numVar,
xlim = c(0,nlevels(catVar)+1),
ylim = ylms,
xaxt = 'n',
col = catVar,
ylab = deparse(substitute(numVar)),
xlab = ifelse(catVar.nm=='NULL', '', catVar.nm),
main = ifelse(main.nm=='NULL', paste0(deparse(substitute(numVar)), ' Plot'), main))
### Add legend:
if(nlevels(catVar) > 1){   # Only needed with multiple levels
legend('bottomright', legend = levels(catVar),
pch=1,
col=1:nlevels(catVar))
}
### Add the violin lines:
if(violin){
L <- list()
for(i in 1:nlevels(catVar)){
d <- density(numVar[as.numeric(catVar)==i], na.rm = TRUE, bw = bw)
L[[i]] <- data.frame(xd=d$x, yd=d$y)
}
names(L) <- levels(catVar)
### We have to scale the densities, need the maximum value for that:
maxD <-  max(sapply(L, function(x){x$yd}))
cexD <- densScl/maxD
### Now plot the densities:
for(i in 1:nlevels(catVar)){
lines(L[[i]]$yd*cexD + i, L[[i]]$xd, col=i)
lines((-L[[i]]$yd)*cexD + i, L[[i]]$xd, col=i)
}
}
### Add the mean-value lines:
if(showMean){
for(i in 1:nlevels(catVar)){
mVal <-  mean(numVar[as.numeric(catVar)==i], na.rm = TRUE)
segments(x0 = i-0.3, y0 = mVal, x1 = i+0.3, y1 = mVal, col = i, lwd = 2)
}
}
### Draw lines of group comparisons:
if(nlevels(catVar) > 1 & sigTest){   # Only run if comparisons were performed
### Draw lines:
for(i in 1:nrow(grCmp)){
xx <- as.numeric(grCmp[i,1:2])
yy <- rep(grCmp[i,'yVal'], 2)
lines(xx, yy)
### Find a good ticklength:
tickL <- (abs(min(ylms)-max(ylms))*0.01)
lines(c(xx[1], xx[1]), c(yy[1], yy[1] - tickL))
lines(c(xx[2], xx[2]), c(yy[2], yy[2] - tickL))
### Add star:
text(x = mean(xx), y = yy[1]+tickL, labels = grCmp[i,'strs'])
}
}
}
niceUnivPlot(iris$Sepal.Length, iris$Species)
niceUnivPlot(iris$Sepal.Length, iris$Species, sigTest = FALSE)
niceUnivPlot(iris$Sepal.Length, iris$Species)
niceUnivPlot(iris$Sepal.Length, iris$Species, multCmp = TRUE)
niceUnivPlot(iris$Petal.Width, iris$Species)
niceUnivPlot(iris$Sepal.Width, iris$Species)
niceUnivPlot(iris$Sepal.Width, iris$Species, sigTest = FALSE)
niceUnivPlot(iris$Sepal.Width, iris$Species)
niceUnivPlot(iris$Sepal.Width, iris$Species, multCmp = TRUE)
niceUnivPlot(iris$Petal.Length, iris$Species, multCmp = TRUE)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test')
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = FALSE)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 2)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 4)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 1)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 0)
niceUnivPlot(iris$Petal.Width*100, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 0)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 0)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 0, ylim.cust = c(0, 3))
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, ylim.cust = c(0, 3))
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, ylim.cust = c(0, 3))
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, ylim.cust = c(0, 4))
library(CustomFunctionsYrotha)
asArguments("numVar, catVar=NULL, violin=TRUE, showMean=TRUE, bw='nrd0', jitFactor=0.2, add.ylim=0, ylim.cust=NULL, densScl=0.5, main=NULL, multCmp=FALSE, sigTest=TRUE")
numVar <- iris$Sepal.Length
catVar
catVar <- iris$Species
ylim.cust <- c(0, 6)
### Check some requirements:
stopifnot(is.numeric(numVar))
stopifnot(is.null(ylim.cust) | length(ylim.cust)==2)   # Check valid entries for ylim.cust
### Set ylim:
if(is.null(ylim.cust)){
ylms <- c(min(numVar, na.rm = TRUE), max(numVar, na.rm = TRUE))
}else{   # Custom ylim
ylms <- ylim.cust
}
ylms <- ylms + c(-add.ylim, add.ylim)   # Add the add.ylim
### Generate catvar:
catVar.nm <- deparse(substitute(catVar))   # Get name of catVar
if(is.null(catVar)){
catVar <- factor(rep(1,length(numVar)))   # 1-level factor
}else{
catVar <- factor(catVar)   # Dont use as.factor, otherwise non-present levels are not removed.
}
#**********************
### Run group comparisons:
if(nlevels(catVar) > 1 & sigTest){   # Only run if catVar has entries of multiple levels
### List group comparisons in table:
grInd <- data.frame(t(combn(1:nlevels(catVar),2)))
### Apply wilcoxon tests to compare corresponding groups (collect pvalues):
wilxP <- apply(grInd, 1, function(x){ wilcox.test(x = numVar[as.numeric(catVar)==x[1]],
y = numVar[as.numeric(catVar)==x[2]])$p.value })
### Combine to table (add bonferonni corrected pvals and y values in plot):
grCmp.0 <- cbind(grInd, wilxP, 'wilxP_bonf'=wilxP*nrow(grInd))
### Add stars:
sigStr <- c('', '*', '**', '***')
sigThr <- c(1.1, 0.05, 0.01, 0.001)   # 1.1 in case pvalue is rounded to 1 (difference in next line has to be negative at least once)
if(multCmp){
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP_bonf < 0.05,]
### Get stars according to bonferroni corrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP_bonf'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}else{
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP < 0.05,]
### Get stars according to uncorrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}
### Add y-values for plot (should not be too far apart):
grCmp$yVal <- max(ylms) + (abs(min(ylms)-max(ylms))*0.05 * 1:nrow(grCmp))
### Adapt ylms:
ylms <- c(ylms[1], ifelse(is.null(ylim.cust), yes = max(grCmp$yVal), no = ylms[2]))
}
grCmp
ylms
### Adapt ylms:
ylms <- c(ylms[1], max(grCmp$yVal))
#**********************
### Get title name:
main.nm <- deparse(substitute(main))
### Start plot:
plot(x = jitter(as.numeric(catVar), factor = jitFactor),
y = numVar,
xlim = c(0,nlevels(catVar)+1),
ylim = ylms,
xaxt = 'n',
col = catVar,
ylab = deparse(substitute(numVar)),
xlab = ifelse(catVar.nm=='NULL', '', catVar.nm),
main = ifelse(main.nm=='NULL', paste0(deparse(substitute(numVar)), ' Plot'), main))
max(grCmp$yVal)
ylms[1]
#*********************************************************************************
#   NICE UNIVARIATE PLOT   ####
#*********************************************************************************
niceUnivPlot <- function(numVar, catVar=NULL, violin=TRUE, showMean=TRUE,
bw='nrd0', jitFactor=0.2, add.ylim=0, ylim.cust=NULL,
densScl=0.5, main=NULL, multCmp=FALSE, sigTest=TRUE){
### Check some requirements:
stopifnot(is.numeric(numVar))
stopifnot(is.null(ylim.cust) | length(ylim.cust)==2)   # Check valid entries for ylim.cust
### Set ylim:
if(is.null(ylim.cust)){
ylms <- c(min(numVar, na.rm = TRUE), max(numVar, na.rm = TRUE))
}else{   # Custom ylim
ylms <- ylim.cust
}
ylms <- ylms + c(-add.ylim, add.ylim)   # Add the add.ylim
### Generate catvar:
catVar.nm <- deparse(substitute(catVar))   # Get name of catVar
if(is.null(catVar)){
catVar <- factor(rep(1,length(numVar)))   # 1-level factor
}else{
catVar <- factor(catVar)   # Dont use as.factor, otherwise non-present levels are not removed.
}
#**********************
### Run group comparisons:
if(nlevels(catVar) > 1 & sigTest){   # Only run if catVar has entries of multiple levels
### List group comparisons in table:
grInd <- data.frame(t(combn(1:nlevels(catVar),2)))
### Apply wilcoxon tests to compare corresponding groups (collect pvalues):
wilxP <- apply(grInd, 1, function(x){ wilcox.test(x = numVar[as.numeric(catVar)==x[1]],
y = numVar[as.numeric(catVar)==x[2]])$p.value })
### Combine to table (add bonferonni corrected pvals and y values in plot):
grCmp.0 <- cbind(grInd, wilxP, 'wilxP_bonf'=wilxP*nrow(grInd))
### Add stars:
sigStr <- c('', '*', '**', '***')
sigThr <- c(1.1, 0.05, 0.01, 0.001)   # 1.1 in case pvalue is rounded to 1 (difference in next line has to be negative at least once)
if(multCmp){
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP_bonf < 0.05,]
### Get stars according to bonferroni corrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP_bonf'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}else{
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP < 0.05,]
### Get stars according to uncorrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}
### Add y-values for plot (should not be too far apart):
grCmp$yVal <- max(ylms) + (abs(min(ylms)-max(ylms))*0.05 * 1:nrow(grCmp))
### Adapt ylms:
ylms <- c(ylms[1], max(grCmp$yVal))
}
#**********************
### Get title name:
main.nm <- deparse(substitute(main))
### Start plot:
plot(x = jitter(as.numeric(catVar), factor = jitFactor),
y = numVar,
xlim = c(0,nlevels(catVar)+1),
ylim = ylms,
xaxt = 'n',
col = catVar,
ylab = deparse(substitute(numVar)),
xlab = ifelse(catVar.nm=='NULL', '', catVar.nm),
main = ifelse(main.nm=='NULL', paste0(deparse(substitute(numVar)), ' Plot'), main))
### Add legend:
if(nlevels(catVar) > 1){   # Only needed with multiple levels
legend('bottomright', legend = levels(catVar),
pch=1,
col=1:nlevels(catVar))
}
### Add the violin lines:
if(violin){
L <- list()
for(i in 1:nlevels(catVar)){
d <- density(numVar[as.numeric(catVar)==i], na.rm = TRUE, bw = bw)
L[[i]] <- data.frame(xd=d$x, yd=d$y)
}
names(L) <- levels(catVar)
### We have to scale the densities, need the maximum value for that:
maxD <-  max(sapply(L, function(x){x$yd}))
cexD <- densScl/maxD
### Now plot the densities:
for(i in 1:nlevels(catVar)){
lines(L[[i]]$yd*cexD + i, L[[i]]$xd, col=i)
lines((-L[[i]]$yd)*cexD + i, L[[i]]$xd, col=i)
}
}
### Add the mean-value lines:
if(showMean){
for(i in 1:nlevels(catVar)){
mVal <-  mean(numVar[as.numeric(catVar)==i], na.rm = TRUE)
segments(x0 = i-0.3, y0 = mVal, x1 = i+0.3, y1 = mVal, col = i, lwd = 2)
}
}
### Draw lines of group comparisons:
if(nlevels(catVar) > 1 & sigTest){   # Only run if comparisons were performed
### Draw lines:
for(i in 1:nrow(grCmp)){
xx <- as.numeric(grCmp[i,1:2])
yy <- rep(grCmp[i,'yVal'], 2)
lines(xx, yy)
### Find a good ticklength:
tickL <- (abs(min(ylms)-max(ylms))*0.01)
lines(c(xx[1], xx[1]), c(yy[1], yy[1] - tickL))
lines(c(xx[2], xx[2]), c(yy[2], yy[2] - tickL))
### Add star:
text(x = mean(xx), y = yy[1]+tickL, labels = grCmp[i,'strs'])
}
}
}
niceUnivPlot(iris$Sepal.Length, iris$Species)
niceUnivPlot(iris$Sepal.Length, iris$Species, ylim.cust = c(0,10))
niceUnivPlot(iris$Sepal.Length, iris$Species, ylim.cust = c(0,15))
niceUnivPlot(iris$Sepal.Length, iris$Species, ylim.cust = c(3,15))
niceUnivPlot(iris$Sepal.Length, iris$Species, ylim.cust = c(3,8))
niceUnivPlot(iris$Sepal.Length, iris$Species, ylim.cust = c(3,8), add.ylim = 2)
devtools::install_github(repo = "ryannick28/CustomFunctionsYrotha", ref = 'main')
library(CustomFunctionsYrotha)
setUpGraph()
niceUnivPlot(iris$Petal.Length, iris$Species)
niceUnivPlot(iris$Sepal.Width, iris$Species)
niceUnivPlot(iris$Sepal.Width, iris$Species, multCmp = TRUE)
niceUnivPlot(iris$Sepal.Width, iris$Species, multCmp = TRUE, add.ylim = 2)
niceUnivPlot(iris$Sepal.Width, iris$Species, multCmp = TRUE, add.ylim = 2, main='iris plot')
