lines(xx, yy)
### Find a good ticklength:
tickL <- (abs(min(ylms)-max(ylms))*0.01)
lines(c(xx[1], xx[1]), c(yy[1], yy[1] - tickL))
lines(c(xx[2], xx[2]), c(yy[2], yy[2] - tickL))
### Add star:
text(x = mean(xx), y = yy[1]+tickL, labels = grCmp[i,'strs'])
#*********************************************************************************
#   NICE UNIVARIATE PLOT   ####
#*********************************************************************************
niceUnivPlot <- function(numVar, catVar=NULL, violin=TRUE, showMean=TRUE,
bw='nrd0', jitFactor=0.2, add.ylim=0, ylim.cust=NULL,
densScl=0.5, main=NULL, multCmp=FALSE, sigTest=TRUE){
### Check some requirements:
stopifnot(is.numeric(numVar))
stopifnot(is.null(ylim.cust) | length(ylim.cust)==2)   # Check valid entries for ylim.cust
### Set ylim:
if(is.null(ylim.cust)){
ylms <- c(min(numVar, na.rm = TRUE), max(numVar, na.rm = TRUE))
}else{   # Custom ylim
ylms <- ylim.cust
}
ylms <- ylms + c(-add.ylim, add.ylim)   # Add the add.ylim
### Generate catvar:
catVar.nm <- deparse(substitute(catVar))   # Get name of catVar
if(is.null(catVar)){
catVar <- factor(rep(1,length(numVar)))   # 1-level factor
}else{
catVar <- factor(catVar)   # Dont use as.factor, otherwise non-present levels are not removed.
}
#**********************
### Run group comparisons:
if(nlevels(catVar) > 1 & sigTest){   # Only run if catVar has entries of multiple levels
### List group comparisons in table:
grInd <- data.frame(t(combn(1:nlevels(catVar),2)))
### Apply wilcoxon tests to compare corresponding groups (collect pvalues):
wilxP <- apply(grInd, 1, function(x){ wilcox.test(x = numVar[as.numeric(catVar)==x[1]],
y = numVar[as.numeric(catVar)==x[2]])$p.value })
### Combine to table (add bonferonni corrected pvals and y values in plot):
grCmp.0 <- cbind(grInd, wilxP, 'wilxP_bonf'=wilxP*nrow(grInd))
### Add stars:
sigStr <- c('', '*', '**', '***')
sigThr <- c(1.1, 0.05, 0.01, 0.001)   # 1.1 in case pvalue is rounded to 1 (difference in next line has to be negative at least once)
if(multCmp){
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP_bonf < 0.05,]
### Get stars according to bonferroni corrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP_bonf'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}else{
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP < 0.05,]
### Get stars according to uncorrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}
### Add y-values for plot (should not be too far apart):
grCmp$yVal <- max(ylms) + (abs(min(ylms)-max(ylms))*0.05 * 1:nrow(grCmp))
### Adapt ylms:
ylms <- c(ylms[1], ifelse(is.null(ylim.cust), yes = max(grCmp$yVal), no = ylms[2]))
}
#**********************
### Get title name:
main.nm <- deparse(substitute(main))
### Start plot:
plot(x = jitter(as.numeric(catVar), factor = jitFactor),
y = numVar,
xlim = c(0,nlevels(catVar)+1),
ylim = ylms,
xaxt = 'n',
col = catVar,
ylab = deparse(substitute(numVar)),
xlab = ifelse(catVar.nm=='NULL', '', catVar.nm),
main = ifelse(main.nm=='NULL', paste0(deparse(substitute(numVar)), ' Plot'), main))
### Add legend:
if(nlevels(catVar) > 1){   # Only needed with multiple levels
legend('bottomright', legend = levels(catVar),
pch=1,
col=1:nlevels(catVar))
}
### Add the violin lines:
if(violin){
L <- list()
for(i in 1:nlevels(catVar)){
d <- density(numVar[as.numeric(catVar)==i], na.rm = TRUE, bw = bw)
L[[i]] <- data.frame(xd=d$x, yd=d$y)
}
names(L) <- levels(catVar)
### We have to scale the densities, need the maximum value for that:
maxD <-  max(sapply(L, function(x){x$yd}))
cexD <- densScl/maxD
### Now plot the densities:
for(i in 1:nlevels(catVar)){
lines(L[[i]]$yd*cexD + i, L[[i]]$xd, col=i)
lines((-L[[i]]$yd)*cexD + i, L[[i]]$xd, col=i)
}
}
### Add the mean-value lines:
if(showMean){
for(i in 1:nlevels(catVar)){
mVal <-  mean(numVar[as.numeric(catVar)==i], na.rm = TRUE)
segments(x0 = i-0.3, y0 = mVal, x1 = i+0.3, y1 = mVal, col = i, lwd = 2)
}
}
### Draw lines of group comparisons:
if(nlevels(catVar) > 1 & sigTest){   # Only run if comparisons were performed
### Draw lines:
for(i in 1:nrow(grCmp)){
xx <- as.numeric(grCmp[i,1:2])
yy <- rep(grCmp[i,'yVal'], 2)
lines(xx, yy)
### Find a good ticklength:
tickL <- (abs(min(ylms)-max(ylms))*0.01)
lines(c(xx[1], xx[1]), c(yy[1], yy[1] - tickL))
lines(c(xx[2], xx[2]), c(yy[2], yy[2] - tickL))
### Add star:
text(x = mean(xx), y = yy[1]+tickL, labels = grCmp[i,'strs'])
}
}
}
niceUnivPlot(iris$Sepal.Length, iris$Species)
niceUnivPlot(iris$Sepal.Length, iris$Species, sigTest = FALSE)
niceUnivPlot(iris$Sepal.Length, iris$Species)
niceUnivPlot(iris$Sepal.Length, iris$Species, multCmp = TRUE)
niceUnivPlot(iris$Petal.Width, iris$Species)
niceUnivPlot(iris$Sepal.Width, iris$Species)
niceUnivPlot(iris$Sepal.Width, iris$Species, sigTest = FALSE)
niceUnivPlot(iris$Sepal.Width, iris$Species)
niceUnivPlot(iris$Sepal.Width, iris$Species, multCmp = TRUE)
niceUnivPlot(iris$Petal.Length, iris$Species, multCmp = TRUE)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test')
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = FALSE)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 2)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 4)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 1)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 0)
niceUnivPlot(iris$Petal.Width*100, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 0)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 0)
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, add.ylim = 0, ylim.cust = c(0, 3))
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, ylim.cust = c(0, 3))
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, ylim.cust = c(0, 3))
niceUnivPlot(iris$Petal.Width, iris$Species, multCmp = TRUE, main = 'test', sigTest = TRUE, ylim.cust = c(0, 4))
library(CustomFunctionsYrotha)
asArguments("numVar, catVar=NULL, violin=TRUE, showMean=TRUE, bw='nrd0', jitFactor=0.2, add.ylim=0, ylim.cust=NULL, densScl=0.5, main=NULL, multCmp=FALSE, sigTest=TRUE")
numVar <- iris$Sepal.Length
catVar
catVar <- iris$Species
ylim.cust <- c(0, 6)
### Check some requirements:
stopifnot(is.numeric(numVar))
stopifnot(is.null(ylim.cust) | length(ylim.cust)==2)   # Check valid entries for ylim.cust
### Set ylim:
if(is.null(ylim.cust)){
ylms <- c(min(numVar, na.rm = TRUE), max(numVar, na.rm = TRUE))
}else{   # Custom ylim
ylms <- ylim.cust
}
ylms <- ylms + c(-add.ylim, add.ylim)   # Add the add.ylim
### Generate catvar:
catVar.nm <- deparse(substitute(catVar))   # Get name of catVar
if(is.null(catVar)){
catVar <- factor(rep(1,length(numVar)))   # 1-level factor
}else{
catVar <- factor(catVar)   # Dont use as.factor, otherwise non-present levels are not removed.
}
#**********************
### Run group comparisons:
if(nlevels(catVar) > 1 & sigTest){   # Only run if catVar has entries of multiple levels
### List group comparisons in table:
grInd <- data.frame(t(combn(1:nlevels(catVar),2)))
### Apply wilcoxon tests to compare corresponding groups (collect pvalues):
wilxP <- apply(grInd, 1, function(x){ wilcox.test(x = numVar[as.numeric(catVar)==x[1]],
y = numVar[as.numeric(catVar)==x[2]])$p.value })
### Combine to table (add bonferonni corrected pvals and y values in plot):
grCmp.0 <- cbind(grInd, wilxP, 'wilxP_bonf'=wilxP*nrow(grInd))
### Add stars:
sigStr <- c('', '*', '**', '***')
sigThr <- c(1.1, 0.05, 0.01, 0.001)   # 1.1 in case pvalue is rounded to 1 (difference in next line has to be negative at least once)
if(multCmp){
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP_bonf < 0.05,]
### Get stars according to bonferroni corrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP_bonf'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}else{
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP < 0.05,]
### Get stars according to uncorrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}
### Add y-values for plot (should not be too far apart):
grCmp$yVal <- max(ylms) + (abs(min(ylms)-max(ylms))*0.05 * 1:nrow(grCmp))
### Adapt ylms:
ylms <- c(ylms[1], ifelse(is.null(ylim.cust), yes = max(grCmp$yVal), no = ylms[2]))
}
grCmp
ylms
### Adapt ylms:
ylms <- c(ylms[1], max(grCmp$yVal))
#**********************
### Get title name:
main.nm <- deparse(substitute(main))
### Start plot:
plot(x = jitter(as.numeric(catVar), factor = jitFactor),
y = numVar,
xlim = c(0,nlevels(catVar)+1),
ylim = ylms,
xaxt = 'n',
col = catVar,
ylab = deparse(substitute(numVar)),
xlab = ifelse(catVar.nm=='NULL', '', catVar.nm),
main = ifelse(main.nm=='NULL', paste0(deparse(substitute(numVar)), ' Plot'), main))
max(grCmp$yVal)
ylms[1]
#*********************************************************************************
#   NICE UNIVARIATE PLOT   ####
#*********************************************************************************
niceUnivPlot <- function(numVar, catVar=NULL, violin=TRUE, showMean=TRUE,
bw='nrd0', jitFactor=0.2, add.ylim=0, ylim.cust=NULL,
densScl=0.5, main=NULL, multCmp=FALSE, sigTest=TRUE){
### Check some requirements:
stopifnot(is.numeric(numVar))
stopifnot(is.null(ylim.cust) | length(ylim.cust)==2)   # Check valid entries for ylim.cust
### Set ylim:
if(is.null(ylim.cust)){
ylms <- c(min(numVar, na.rm = TRUE), max(numVar, na.rm = TRUE))
}else{   # Custom ylim
ylms <- ylim.cust
}
ylms <- ylms + c(-add.ylim, add.ylim)   # Add the add.ylim
### Generate catvar:
catVar.nm <- deparse(substitute(catVar))   # Get name of catVar
if(is.null(catVar)){
catVar <- factor(rep(1,length(numVar)))   # 1-level factor
}else{
catVar <- factor(catVar)   # Dont use as.factor, otherwise non-present levels are not removed.
}
#**********************
### Run group comparisons:
if(nlevels(catVar) > 1 & sigTest){   # Only run if catVar has entries of multiple levels
### List group comparisons in table:
grInd <- data.frame(t(combn(1:nlevels(catVar),2)))
### Apply wilcoxon tests to compare corresponding groups (collect pvalues):
wilxP <- apply(grInd, 1, function(x){ wilcox.test(x = numVar[as.numeric(catVar)==x[1]],
y = numVar[as.numeric(catVar)==x[2]])$p.value })
### Combine to table (add bonferonni corrected pvals and y values in plot):
grCmp.0 <- cbind(grInd, wilxP, 'wilxP_bonf'=wilxP*nrow(grInd))
### Add stars:
sigStr <- c('', '*', '**', '***')
sigThr <- c(1.1, 0.05, 0.01, 0.001)   # 1.1 in case pvalue is rounded to 1 (difference in next line has to be negative at least once)
if(multCmp){
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP_bonf < 0.05,]
### Get stars according to bonferroni corrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP_bonf'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}else{
### Filter out only significant tests:
grCmp <- grCmp.0[grCmp.0$wilxP < 0.05,]
### Get stars according to uncorrected pvalues:
grCmp$strs <- sapply(grCmp[,'wilxP'], function(x){ sigStr[max(which((x - sigThr) < 0))] })
}
### Add y-values for plot (should not be too far apart):
grCmp$yVal <- max(ylms) + (abs(min(ylms)-max(ylms))*0.05 * 1:nrow(grCmp))
### Adapt ylms:
ylms <- c(ylms[1], max(grCmp$yVal))
}
#**********************
### Get title name:
main.nm <- deparse(substitute(main))
### Start plot:
plot(x = jitter(as.numeric(catVar), factor = jitFactor),
y = numVar,
xlim = c(0,nlevels(catVar)+1),
ylim = ylms,
xaxt = 'n',
col = catVar,
ylab = deparse(substitute(numVar)),
xlab = ifelse(catVar.nm=='NULL', '', catVar.nm),
main = ifelse(main.nm=='NULL', paste0(deparse(substitute(numVar)), ' Plot'), main))
### Add legend:
if(nlevels(catVar) > 1){   # Only needed with multiple levels
legend('bottomright', legend = levels(catVar),
pch=1,
col=1:nlevels(catVar))
}
### Add the violin lines:
if(violin){
L <- list()
for(i in 1:nlevels(catVar)){
d <- density(numVar[as.numeric(catVar)==i], na.rm = TRUE, bw = bw)
L[[i]] <- data.frame(xd=d$x, yd=d$y)
}
names(L) <- levels(catVar)
### We have to scale the densities, need the maximum value for that:
maxD <-  max(sapply(L, function(x){x$yd}))
cexD <- densScl/maxD
### Now plot the densities:
for(i in 1:nlevels(catVar)){
lines(L[[i]]$yd*cexD + i, L[[i]]$xd, col=i)
lines((-L[[i]]$yd)*cexD + i, L[[i]]$xd, col=i)
}
}
### Add the mean-value lines:
if(showMean){
for(i in 1:nlevels(catVar)){
mVal <-  mean(numVar[as.numeric(catVar)==i], na.rm = TRUE)
segments(x0 = i-0.3, y0 = mVal, x1 = i+0.3, y1 = mVal, col = i, lwd = 2)
}
}
### Draw lines of group comparisons:
if(nlevels(catVar) > 1 & sigTest){   # Only run if comparisons were performed
### Draw lines:
for(i in 1:nrow(grCmp)){
xx <- as.numeric(grCmp[i,1:2])
yy <- rep(grCmp[i,'yVal'], 2)
lines(xx, yy)
### Find a good ticklength:
tickL <- (abs(min(ylms)-max(ylms))*0.01)
lines(c(xx[1], xx[1]), c(yy[1], yy[1] - tickL))
lines(c(xx[2], xx[2]), c(yy[2], yy[2] - tickL))
### Add star:
text(x = mean(xx), y = yy[1]+tickL, labels = grCmp[i,'strs'])
}
}
}
niceUnivPlot(iris$Sepal.Length, iris$Species)
niceUnivPlot(iris$Sepal.Length, iris$Species, ylim.cust = c(0,10))
niceUnivPlot(iris$Sepal.Length, iris$Species, ylim.cust = c(0,15))
niceUnivPlot(iris$Sepal.Length, iris$Species, ylim.cust = c(3,15))
niceUnivPlot(iris$Sepal.Length, iris$Species, ylim.cust = c(3,8))
niceUnivPlot(iris$Sepal.Length, iris$Species, ylim.cust = c(3,8), add.ylim = 2)
devtools::install_github(repo = "ryannick28/CustomFunctionsYrotha", ref = 'main')
library(CustomFunctionsYrotha)
setUpGraph()
niceUnivPlot(iris$Petal.Length, iris$Species)
niceUnivPlot(iris$Sepal.Width, iris$Species)
niceUnivPlot(iris$Sepal.Width, iris$Species, multCmp = TRUE)
niceUnivPlot(iris$Sepal.Width, iris$Species, multCmp = TRUE, add.ylim = 2)
niceUnivPlot(iris$Sepal.Width, iris$Species, multCmp = TRUE, add.ylim = 2, main='iris plot')
devtools::install_github(repo = "ryannick28/CustomFunctionsYrotha", ref = 'main')
library(CustomFunctionsYrotha)
setUpGraph()
?niceUnivPlot
devtools::install_github(repo = "ryannick28/CustomFunctionsYrotha", ref = 'main')
devtools::install_github(repo = "ryannick28/CustomFunctionsYrotha", ref = 'main')
library(CustomFunctionsYrotha)
setUpGraph()
dat <- mmdgp()
head(dat)
library(lmerTest)
summary(lmer(y ~gen + age + day + (1|id) + (1|class()), dat))
summary(lmer(y ~gen + age + day + (1|id) + (1|class), dat))
dat <- mmdgp(tb = c(0,1,20))
head(dat, 20)
table(dat$class)
summary(lmer(y ~gen + age + day + (1|id) + (1|class), dat))
dat
dat <-
summary(lmer(y ~gen + age + day + (1|id) + (1|class), dat))
dat <- mmdgp(tb=1:8)
summary(lmer(y ~gen + age + day + (1|id) + (1|class), dat))
dat <- mmdgp(tb=0:8)
summary(lmer(y ~gen + age + day + (1|id) + (1|class), dat))
setUpGraph()
head(dat)
str(dat)
niceUnivPlot(numVar = dat$y, catVar = dat$day)
niceUnivPlot(numVar = dat$y, catVar = dat$day, pairedVar = dat$id)
niceUnivPlot(numVar = dat$y, catVar = dat$day,
pairedVar = dat$id, pairCol = dat$age)
niceUnivPlot(numVar = dat$y, catVar = dat$day, fxdCol = 'blue',
pairedVar = dat$id, pairCol = dat$age)
niceUnivPlot(numVar = dat$y, catVar = dat$day, fxdCol = 'black',
pairedVar = dat$id, pairCol = dat$age)
dat <- mmdgp(tb=0:8, genb = 30)
summary(lmer(y ~gen + age + day + (1|id) + (1|class), dat))
niceUnivPlot(numVar = dat$y, catVar = dat$day, fxdCol = 'black',
pairedVar = dat$id, pairCol = dat$age)
dat <- mmdgp(tb=0:8, genb = 60)
summary(lmer(y ~gen + age + day + (1|id) + (1|class), dat))
niceUnivPlot(numVar = dat$y, catVar = dat$day, fxdCol = 'black',
pairedVar = dat$id, pairCol = dat$age)
d1 <- dat[dat$gen=='M',]
d1
d2 <- dat[dat$gen=='F',]
niceUnivPlot(numVar = d1$y, catVar = d1$day, fxdCol = 'blue', pairedVar = d1$id)
niceUnivPlot(numVar = d1$y, catVar = d1$day,
fxdCol = 'blue', pairedVar = d1$id, pairCol = d1$age)
niceUnivPlot(numVar = d2$y, catVar = d2$day,
fxdCol = 'red', pairedVar = d2$id, pairCol = d2$age)
niceUnivPlot(numVar = d1$y, catVar = d1$day,
fxdCol = 'blue', pairedVar = d1$id, pairCol = d1$age)
niceUnivPlot(numVar = d2$y, catVar = d2$day,
fxdCol = 'red', pairedVar = d2$id, pairCol = d2$age, add = TRUE)
niceUnivPlot(numVar = d1$y, catVar = d1$day, add.ylim = 60,
fxdCol = 'blue', pairedVar = d1$id, pairCol = d1$age)
niceUnivPlot(numVar = d2$y, catVar = d2$day,
fxdCol = 'red', pairedVar = d2$id, pairCol = d2$age, add = TRUE)
niceUnivPlot(numVar = d2$y, catVar = d2$day,
fxdCol = 'red', pairedVar = d1$id, pairCol = d2$age, add = TRUE)
niceUnivPlot(numVar = d2$y, catVar = d2$day,
fxdCol = 'red', pairedVar = dat$id, pairCol = d2$age, add = TRUE)
niceUnivPlot(numVar = d2$y, catVar = d2$day,
fxdCol = 'red', pairedVar = d2$id, pairCol = d2$age, add = TRUE)
dat <- mmdgp(tb=0:8, genb = 60, nC = 7)
dat <- mmdgp(tb=0:8, genb = 60, nC = 7)
mmdgp
CustomFunctionsYrotha::asArguments("n=200, nC=5, sd_S=3, sd_C=5, sd_e=2, b0=50, tb=c(0,4,10,4,0), genb=10, ageb=1")
nC
nC <- 7
### Generate subjects:
id <- factor(paste0('S', 1:n), levels = paste0('S', 1:n))
### Generate random intercept of subjects:
id.ri <- rnorm(n, sd=sd_S)
### Generate age variable:
age <- ceiling(runif(n, min = 20, max = 70))
### Generate class factor:
class <- factor(paste0('Class', 1:nC), levels = paste0('Class', 1:nC))
### Generate class random intercept:
clss.ri <- rnorm(nC, sd=sd_C)
### Generate gender variable:
gen <- 0:1
### Combine to data frame:
ds <- data.frame(id, class, gen, age, id.ri, clss.ri)
id
class
gen
age
id.ri
clss.ri
### Combine to data frame:
ds <- data.frame(id, gen, age, id.ri, clss.ri)
### Combine to data frame:
ds <- data.frame(id, gen, age, id.ri)
ds$class <- class
### Combine to data frame:
ds <- data.frame(id, gen, age, id.ri, 1)
ds
### Combine to data frame:
ds <- data.frame(id, gen, age, id.ri, 1:7)
n
nC
n/nC
n//nC
n%/%nC
n%%nC
10%%3
stop('There has to be an equal number of people in each class. Currently, the number of people is not divisible by the number of classes.')
#*********************************************************************************
#   MIXED MODEL DGP   ####
#*********************************************************************************
mmdgp <- function(n=200, nC=5, sd_S=3, sd_C=5, sd_e=2, b0=50, tb=c(0,4,10,4,0),
genb=10, ageb=1){
### Check some condition:
if(n%%nC!=0){stop('There has to be an equal number of people in each class. Currently, the number of people is not divisible by the number of classes.')}
### Generate subjects:
id <- factor(paste0('S', 1:n), levels = paste0('S', 1:n))
### Generate random intercept of subjects:
id.ri <- rnorm(n, sd=sd_S)
### Generate age variable:
age <- ceiling(runif(n, min = 20, max = 70))
### Generate class factor:
class <- factor(paste0('Class', 1:nC), levels = paste0('Class', 1:nC))
### Generate class random intercept:
clss.ri <- rnorm(nC, sd=sd_C)
### Generate gender variable:
gen <- 0:1
### Combine to data frame:
ds <- data.frame(id, class, gen, age, id.ri, clss.ri)
ds <- ds[order(ds$class, ds$id),]   # Order after classes and individuals
ds$gen <- sample(ds$gen)   # mix up gender
### Generate target variable for each day:
### First replicate each row in data frame for each day:
dat.0 <- replicate(length(tb), ds, simplify = FALSE)
dat.0 <- Reduce(f = function(a,b)rbind(a,b), x = dat.0)
dat.0 <- dat.0[order(dat.0$class, dat.0$id),]   # Reorder
### Add day variable:
dat.0$day <- 1:length(tb)
### Add random error:
dat.0$err <- rnorm(nrow(dat.0), sd=sd_e)
### Generate target variable for each day (bit messy...):
dd <- dat.0[, -which(colnames(dat.0) %in% c('id', 'class', 'day'))]   # Remove some variables
dd$dayEff <- tb
dd$b0 <- b0
dat.0$y <- apply(dd, 1, function(x){
t(as.matrix(x))%*%c(genb, ageb, 1, 1, 1, 1, 1)
})
### Remove the columns not needed:
dat <- dat.0
dat$id.ri <- NULL
dat$clss.ri <- NULL
dat$err <- NULL
### Gender to factor:
dat$gen <- factor(dat$gen, levels = c(0,1), labels = c('M','F'))
### Day to factor:
dat$day <- as.factor(dat$day)
### Return object:
return(dat)
}
mmdgp()
a <- mmdgp()
a <- mmdgp(n=10)
a <- mmdgp(n=10, nC=3)
a <- mmdgp(n=10, nC=2)
a <- mmdgp(n=10, nC=1)
devtools::install_github(repo = "ryannick28/CustomFunctionsYrotha", ref = 'main')
library(CustomFunctionsYrotha)
mmdgp(n=100)
mmdgp(n=100, nC=33)
devtools::install_github(repo = "ryannick28/CustomFunctionsYrotha", ref = 'main')
library(CustomFunctionsYrotha)
nice3DPlot(iris)
devtools::install_github(repo = "ryannick28/CustomFunctionsYrotha", ref = 'main')
