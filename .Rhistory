rbPal <- grDevices::colorRampPalette(c('blue', 'red'))
den_coor$col <- rbPal(colres)[as.numeric(cut(den_coor$dens,breaks = colres))]   # Here the progression of the colour pallette is defined
### Plot the points and or density:
stopifnot(whatToPlot[1] %in% c('P','D', 'PD'))
### See if catVar was supplied and adapt colour accordingly:
if(!is.null(catVar)){
stopifnot(is.factor(catVar))
pointCol <- as.numeric(catVar)
}
if(whatToPlot[1]=='P'){
rgl::rgl.points(X, color=pointCol, size=pointSize, alpha=pointTrans)
} else if (whatToPlot[1]=='D'){
rgl::rgl.points(den_coor[,1:3], color=den_coor$col, size=DpointSize, alpha=den_coor$dens/max(den_coor$dens)*Dtransp_fac)   # Here also the progression of the transparency is defined
} else if (whatToPlot[1]=='PD'){
rgl::rgl.points(X, color=pointCol, size=pointSize, alpha=pointTrans)
rgl::rgl.points(den_coor[,1:3], color=den_coor$col, size=DpointSize, alpha=den_coor$dens/max(den_coor$dens)*Dtransp_fac)   # Here also the progression of the transparency is defined
}
### Add a surface of the linear regression fit:
if(plotFit[1]!='no'){
x1.pred <- seq(min(X[,1]), max(X[,1]), length.out = 100)   # Have to take the first and third column because third is target variable in plot
x2.pred <- seq(min(X[,3]), max(X[,3]), length.out = 100)
x1x2.pred <- expand.grid("x1"=x1.pred, "x2"=x2.pred)
### Fit lm:
lm.ypred <- lm(X[,2] ~ X[,1] + X[,3])
coeffs <- summary(lm.ypred)$coefficients[,1]
y.pred <- matrix((coeffs[1] + coeffs[2]*x1x2.pred$x1 + coeffs[3]*x1x2.pred$x2), ncol = length(x1.pred))
### In case of interaction wanted:
if(plotFit[1]=='int'){
lm.ypred <- lm(X[,2] ~ X[,1] * X[,3])
coeffs <- summary(lm.ypred)$coefficients[,1]
y.pred <- matrix((coeffs[1] + coeffs[2]*x1x2.pred$x1 + coeffs[3]*x1x2.pred$x2 + coeffs[4]*x1x2.pred$x1*x1x2.pred$x2), ncol = length(x1.pred))
}
### Plot surface:
rgl::rgl.surface(x1.pred, x2.pred, y.pred, color = "steelblue",
alpha = 0.5, lit = FALSE)
}
} else {   # Only plot empty coordinate system
if(is.null(axesNames)) {axesNames <- c('x','y','z')}
axesLeng <- 1   # Set axes length
.coorSystem3D(axesNames, gridCol, axesLeng, axesTicks, zoom)
}
}
test3d(iris)
test3d(iris, catVar = iris$Species)
catVar
catVar <- as.factor(rep(1, nrow(X)))   # Otherwise create 1-level factor for catVar
catVar <- as.factor(rep(1, nrow(iris)))   # Otherwise create 1-level factor for catVar
catVar
1:nlevels(catVar)
iris$Species
as.numeric(iris$Species)
sel <- (as.numeric(catVar)==l)
l <- 1
sel <- (as.numeric(catVar)==l)
sel
?rgl.surface
test3d <- function(X = NULL, whatToPlot = c('P','D','PD'), plotFit = c('no','lin','int'), catVar = NULL, covMat = NULL, means = NULL, nSim = 500, pointCol = 1, pointSize = 5, pointTrans = 0.8, Dtransp_fac = 0.06, colres = 50, gridRes = 30, h = 0.3, DpointSize = 30, axesNames = NULL, axesTicks = FALSE, gridCol = 'grey', axesLeng = NULL, zoom = 1){
### Check whether data is provided or empty coordinate system should be plotted.
if(!is.null(X) | !is.null(means) | !is.null(covMat)){   # Only go on if one of the three things is defined
### Check whether simulated or provided data should be plotted:
if (!is.null(X)){   # In case X is provided
if(sum(unlist(lapply(as.data.frame(X), is.na))) > 0){   # Check for missing values
warning("There are missing values in the data. Will remove the rows containing missing values.")
### Remove rows containing NAs:
X <- X[apply(X, 1, function(x){all(!is.na(x))}),]
}
if(ncol(X)>3){warning('More than three variables in the data. Will select the first three columns for plotting.')}
x <- X[,1]
y <- X[,2]
z <- X[,3]
if(is.null(axesNames)) {axesNames <- colnames(X)[1:3]}
} else if(!is.null(covMat) & !is.null(means)){   # Plot simulated data from multivariate normal distribution
X <- mvtnorm::rmvnorm(n = nSim, mean = means, sigma = covMat)   # Alternative: method = 'svd'
dimnames(X) <- list(NULL, c('x','y', 'z'))
x <- X[,'x']
y <- X[,'y']
z <- X[,'z']
if(is.null(axesNames)) {axesNames <- c('x','y','z')}
} else {
stop('No data (X) is provided. For a simulation either the vector of means or the covariance matrix is missing. To run a Simulation both are needed.')
}
### Generate (empty) 3D coordinate system:
### Set axis-length:
if(is.null(axesLeng)){
axesLeng <- max(X[,unlist(lapply(as.data.frame(X), is.numeric))], na.rm = TRUE)*1.5
}
### Plot empty coordinate system:
.coorSystem3D(axesNames, gridCol, axesLeng, axesTicks, zoom)
### Apply the kernel density estimator:
dens <-  misc3d::kde3d(x,y,z, h = h, n = gridRes)
### Create the matrix needed for the rgl.points (this is simply a rearrangement to get everything in one table)
indices <- expand.grid(1:gridRes, 1:gridRes, 1:gridRes)
colnames(indices) <- c('x', 'y', 'z')
den_coor <- expand.grid(dens$x, dens$y, dens$z)
colnames(den_coor) <- c('x', 'y', 'z')
convertFunc <- function(x, dat){dat[x[1], x[2], x[3]]}
den_coor$dens <-  apply(indices, 1, convertFunc, dat=dens$d)
### Colour palette:
rbPal <- grDevices::colorRampPalette(c('blue', 'red'))
den_coor$col <- rbPal(colres)[as.numeric(cut(den_coor$dens,breaks = colres))]   # Here the progression of the colour pallette is defined
### Plot the points and or density:
stopifnot(whatToPlot[1] %in% c('P','D', 'PD'))
### See if catVar was supplied and adapt colour accordingly:
if(!is.null(catVar)){
stopifnot(is.factor(catVar))
pointCol <- as.numeric(catVar)
}else{
catVar <- as.factor(rep(1, nrow(X)))   # Otherwise create 1-level factor for catVar
}
### Start plotting:
if(whatToPlot[1]=='P'){
rgl::rgl.points(X, color=pointCol, size=pointSize, alpha=pointTrans)
} else if (whatToPlot[1]=='D'){
rgl::rgl.points(den_coor[,1:3], color=den_coor$col, size=DpointSize, alpha=den_coor$dens/max(den_coor$dens)*Dtransp_fac)   # Here also the progression of the transparency is defined
} else if (whatToPlot[1]=='PD'){
rgl::rgl.points(X, color=pointCol, size=pointSize, alpha=pointTrans)
rgl::rgl.points(den_coor[,1:3], color=den_coor$col, size=DpointSize, alpha=den_coor$dens/max(den_coor$dens)*Dtransp_fac)   # Here also the progression of the transparency is defined
}
### Add a surface of the linear regression fit:
for(l in 1:nlevels(catVar)){   # Iterate through all catVar levels
sel <- (as.numeric(catVar)==l)   # Selection only of factor level observations
### Check plotFit argument:
if(plotFit[1]!='no'){
x1.pred <- seq(min(X[,1]), max(X[,1]), length.out = 100)   # Have to take the first and third column because second is target variable in plot
x2.pred <- seq(min(X[,3]), max(X[,3]), length.out = 100)
x1x2.pred <- expand.grid("x1"=x1.pred, "x2"=x2.pred)
### Fit lm:
lm.ypred <- lm(X[sel,2] ~ X[sel,1] + X[sel,3])
coeffs <- summary(lm.ypred)$coefficients[,1]
y.pred <- matrix((coeffs[1] + coeffs[2]*x1x2.pred$x1 + coeffs[3]*x1x2.pred$x2), ncol = length(x1.pred))
### In case of interaction wanted:
if(plotFit[1]=='int'){
lm.ypred <- lm(X[sel,2] ~ X[sel,1] * X[sel,3])
coeffs <- summary(lm.ypred)$coefficients[,1]
y.pred <- matrix((coeffs[1] + coeffs[2]*x1x2.pred$x1 + coeffs[3]*x1x2.pred$x2 + coeffs[4]*x1x2.pred$x1*x1x2.pred$x2), ncol = length(x1.pred))
}
### Plot surface:
srfCl <- ifelse(test = nlevels(catVar) > 1, yes = l, no = "steelblue")
rgl::rgl.surface(x1.pred, x2.pred, y.pred, color = srfCl,
alpha = 0.5, lit = FALSE)
}
}
} else {   # Only plot empty coordinate system
if(is.null(axesNames)) {axesNames <- c('x','y','z')}
axesLeng <- 1   # Set axes length
.coorSystem3D(axesNames, gridCol, axesLeng, axesTicks, zoom)
}
}
test3d(iris)
test3d(iris[,1:3])
test3d(iris[,1:3], catVar = iris$Species)
test3d(iris[,1:3], catVar = iris$Species, plotFit = 'lin')
test3d(iris[,1:3], catVar = iris$Species, plotFit = 'int')
test3d(iris[,1:3], catVar = iris$Species, plotFit = 'lin')
catVar
### Fit lm:
lm.ypred <- ifelse(test = nlevels(catVar) > 1, yes = lm(X[,2] ~ X[,1] + X[,3] + catVar), no = lm(X[,2] ~ X[,1] + X[,3]))
X <- iris
### Fit lm:
lm.ypred <- ifelse(test = nlevels(catVar) > 1, yes = lm(X[,2] ~ X[,1] + X[,3] + catVar), no = lm(X[,2] ~ X[,1] + X[,3]))
lm.ypred
summary(lm.ypred)
catVar
lm(X[,2] ~ X[,1] + X[,3])
rm(X)
lm.ypred <- lm(X[,2] ~ X[,1] + X[,3] + catVar)
X <- iris
lm.ypred <- lm(X[,2] ~ X[,1] + X[,3] + catVar)
lm.ypred <- lm(X[,2] ~ X[,1] + X[,3] + iris$Species)
summary(lm.ypred <- lm(X[,2] ~ X[,1] + X[,3] + iris$Species))
coeffs <- summary(lm.ypred)$coefficients[,1]
coeffs[3]
summary(lm.ypred)$coefficients
summary(lm.ypred)$coefficients ->a
a
rownames(a)
levels(iris$Species)[1]
levels(iris$Species)[1] %in% rownames(a)
grepl(levels(iris$Species)[1], rownames(a))
grepl(levels(iris$Species)[2], rownames(a))
a
coeffs[grepl(levels(iris$Species)[2], rownames(a))]
coeffs[grepl(levels(iris$Species)[1], rownames(a))]
coeffs[grepl(levels(iris$Species)[1], rownames(a))] + 1
coeffs[grepl(levels(iris$Species)[1], rownames(a))]
coeffs[grepl(levels(iris$Species)[2], rownames(a))]
as.numeric(coeffs[grepl(levels(iris$Species)[2], rownames(a))])
as.numeric(coeffs[grepl(levels(iris$Species)[1], rownames(a))])
as.numeric(coeffs[grepl(levels(iris$Species)[1], rownames(a))]) + 1
as.numeric(coeffs[grepl(levels(iris$Species)[2], rownames(a))])
as.numeric(coeffs[grepl(levels(iris$Species)[2], rownames(a))]) + 1
test3d <- function(X = NULL, whatToPlot = c('P','D','PD'), plotFit = c('no','lin','int'), catVar = NULL, covMat = NULL, means = NULL, nSim = 500, pointCol = 1, pointSize = 5, pointTrans = 0.8, Dtransp_fac = 0.06, colres = 50, gridRes = 30, h = 0.3, DpointSize = 30, axesNames = NULL, axesTicks = FALSE, gridCol = 'grey', axesLeng = NULL, zoom = 1){
### Check whether data is provided or empty coordinate system should be plotted.
if(!is.null(X) | !is.null(means) | !is.null(covMat)){   # Only go on if one of the three things is defined
### Check whether simulated or provided data should be plotted:
if (!is.null(X)){   # In case X is provided
if(sum(unlist(lapply(as.data.frame(X), is.na))) > 0){   # Check for missing values
warning("There are missing values in the data. Will remove the rows containing missing values.")
### Remove rows containing NAs:
X <- X[apply(X, 1, function(x){all(!is.na(x))}),]
}
if(ncol(X)>3){warning('More than three variables in the data. Will select the first three columns for plotting.')}
x <- X[,1]
y <- X[,2]
z <- X[,3]
if(is.null(axesNames)) {axesNames <- colnames(X)[1:3]}
} else if(!is.null(covMat) & !is.null(means)){   # Plot simulated data from multivariate normal distribution
X <- mvtnorm::rmvnorm(n = nSim, mean = means, sigma = covMat)   # Alternative: method = 'svd'
dimnames(X) <- list(NULL, c('x','y', 'z'))
x <- X[,'x']
y <- X[,'y']
z <- X[,'z']
if(is.null(axesNames)) {axesNames <- c('x','y','z')}
} else {
stop('No data (X) is provided. For a simulation either the vector of means or the covariance matrix is missing. To run a Simulation both are needed.')
}
### Generate (empty) 3D coordinate system:
### Set axis-length:
if(is.null(axesLeng)){
axesLeng <- max(X[,unlist(lapply(as.data.frame(X), is.numeric))], na.rm = TRUE)*1.5
}
### Plot empty coordinate system:
.coorSystem3D(axesNames, gridCol, axesLeng, axesTicks, zoom)
### Apply the kernel density estimator:
dens <-  misc3d::kde3d(x,y,z, h = h, n = gridRes)
### Create the matrix needed for the rgl.points (this is simply a rearrangement to get everything in one table)
indices <- expand.grid(1:gridRes, 1:gridRes, 1:gridRes)
colnames(indices) <- c('x', 'y', 'z')
den_coor <- expand.grid(dens$x, dens$y, dens$z)
colnames(den_coor) <- c('x', 'y', 'z')
convertFunc <- function(x, dat){dat[x[1], x[2], x[3]]}
den_coor$dens <-  apply(indices, 1, convertFunc, dat=dens$d)
### Colour palette:
rbPal <- grDevices::colorRampPalette(c('blue', 'red'))
den_coor$col <- rbPal(colres)[as.numeric(cut(den_coor$dens,breaks = colres))]   # Here the progression of the colour pallette is defined
### Plot the points and or density:
stopifnot(whatToPlot[1] %in% c('P','D', 'PD'))
### See if catVar was supplied and adapt colour accordingly:
if(!is.null(catVar)){
stopifnot(is.factor(catVar))
pointCol <- as.numeric(catVar)
}else{
catVar <- as.factor(rep(1, nrow(X)))   # Otherwise create 1-level factor for catVar
}
### Start plotting:
if(whatToPlot[1]=='P'){
rgl::rgl.points(X, color=pointCol, size=pointSize, alpha=pointTrans)
} else if (whatToPlot[1]=='D'){
rgl::rgl.points(den_coor[,1:3], color=den_coor$col, size=DpointSize, alpha=den_coor$dens/max(den_coor$dens)*Dtransp_fac)   # Here also the progression of the transparency is defined
} else if (whatToPlot[1]=='PD'){
rgl::rgl.points(X, color=pointCol, size=pointSize, alpha=pointTrans)
rgl::rgl.points(den_coor[,1:3], color=den_coor$col, size=DpointSize, alpha=den_coor$dens/max(den_coor$dens)*Dtransp_fac)   # Here also the progression of the transparency is defined
}
### Add a surface of the linear regression fit:
for(l in 1:nlevels(catVar)){   # Iterate through all catVar levels
sel <- (as.numeric(catVar)==l)   # Selection only of factor level observations
### Check plotFit argument:
if(plotFit[1]!='no'){
x1.pred <- seq(min(X[,1]), max(X[,1]), length.out = 100)   # Have to take the first and third column because second is target variable in plot
x2.pred <- seq(min(X[,3]), max(X[,3]), length.out = 100)
x1x2.pred <- expand.grid("x1"=x1.pred, "x2"=x2.pred)
### Fit lm:
if(nlevels(catVar) > 1){
lm.ypred <- lm(X[,2] ~ X[,1] + X[,3] + catVar)
}else{
lm.ypred <- lm(X[,2] ~ X[,1] + X[,3])
}
coeffs <- summary(lm.ypred)$coefficients[,1]
### Calculate factor intercept:
facInt <- ifelse(l > 1,
yes = coeffs[grepl(levels(catVar)[l], rownames(summary(lm.ypred)$coefficients))],
no = 0)
y.pred <- matrix((facInt + coeffs[1] + coeffs[2]*x1x2.pred$x1 + coeffs[3]*x1x2.pred$x2), ncol = length(x1.pred))
### In case of interaction wanted:
if(plotFit[1]=='int'){
lm.ypred <- lm(X[sel,2] ~ X[sel,1] * X[sel,3])
coeffs <- summary(lm.ypred)$coefficients[,1]
y.pred <- matrix((coeffs[1] + coeffs[2]*x1x2.pred$x1 + coeffs[3]*x1x2.pred$x2 + coeffs[4]*x1x2.pred$x1*x1x2.pred$x2), ncol = length(x1.pred))
}
### Plot surface:
srfCl <- ifelse(test = nlevels(catVar) > 1, yes = l, no = "steelblue")
rgl::rgl.surface(x1.pred, x2.pred, y.pred, color = srfCl,
alpha = 0.5, lit = FALSE)
}
}
} else {   # Only plot empty coordinate system
if(is.null(axesNames)) {axesNames <- c('x','y','z')}
axesLeng <- 1   # Set axes length
.coorSystem3D(axesNames, gridCol, axesLeng, axesTicks, zoom)
}
}
test3d(iris)
test3d(iris[,1:3])
test3d(iris[,1:3], colres = as.numeric(iris$Species))
test3d(iris[,1:3])
test3d(iris[,1:3], pointCol = iris$Species)
test3d(iris[,1:3], pointCol = as.numeric(iris$Species))
test3d(iris[,1:3], catVar = iris$Species)
test3d(iris[,1:3], catVar = iris$Species, plotFit = 'no')
test3d(iris[,1:3], catVar = iris$Species, plotFit = 'lin')
test3d(iris[,1:3], catVar = iris$Species, plotFit = 'int')
head(iris)
test3d(iris[,1:3])
test3d(iris[,1:3], plotFit = 'lin')
test3d(iris[,1:3], plotFit = 'int')
test3d(iris[,1:3], plotFit = 'lin', catVar = iris$Species)
test3d(iris[,1:3], plotFit = 'int', catVar = iris$Species)
test3d(iris[,1:3], plotFit = 'lin', catVar = iris$Species)
test3d(iris[,1:3], plotFit = 'lin', pointCol = as.numeric(iris$Species))
test3d(iris[,1:3], plotFit = 'lin', catVar = iris$Species)
test3d(iris[,1:3], plotFit = 'int', pointCol = as.numeric(iris$Species))
test3d([iris[,2:4]])
test3d(iris$[,2:4])
test3d(iris[,2:4])
test3d(iris[,2:4], catVar = iris$Species)
test3d(iris[,2:4], catVar = iris$Species, plotFit = 'lin')
test3d(iris[,2:4], plotFit = 'lin')
test3d(iris[,2:4], catVar = iris$Species, plotFit = 'lin')
test3d(iris[,2:4], catVar = iris$Species, plotFit = 'int')
library(CustomFunctions)
nice3DPlot(iris[,2:4])
nice3DPlot(iris[,2:4], whatToPlot = 'D')
nice3DPlot(iris[,2:4], whatToPlot = 'D', plotFit = 'lin')
nice3DPlot(iris[,2:4], whatToPlot = 'D', plotFit = 'int')
library(CustomFunctions)
library(CustomFunctions)
nice3DPlot(iris)
library(CustomFunctions)
library(CustomFunctions)
asArguments("X = NULL, whatToPlot = c('P','D','PD'), plotFit = c('no','lin','int'), catVar = NULL, covMat = NULL, means = NULL, nSim = 500, pointCol = 1, pointSize = 5, pointTrans = 0.8, Dtransp_fac = 0.06, colres = 50, gridRes = 30, h = 0.3, DpointSize = 30, axesNames = NULL, axesTicks = FALSE, gridCol = 'grey', axesLeng = NULL, zoom = 1")
dat <- read.csv(file = './df.ema_call_bt.csv', stringsAsFactors = TRUE)
dat <- read.csv(file = '../../../../../Desktop/PostDoc_Unterlagen/Arbeit/statistischeBeratung/AnjaRies_UND_JennyStutz_Feb2021/df.ema_call_bt.csv', stringsAsFactors = TRUE)
X <- dat
noNaSel <- apply(X, 1, function(x){all(!is.na(x))})
noNaSel
X <- dat[,c(8, 4, 12)]
noNaSel <- apply(X, 1, function(x){all(!is.na(x))})
noNaSel
sum(noNaSel)
X <- dat[dat$gender==0,c(8, 4, 12)]
apply(X, 1, function(x){all(!is.na(x))})
head(X)
X
X2 <- dat[dat$gender==0,c(8, 4, 12)]
apply(X, 1, function(x){all(!is.na(x))})
apply(X, 1, function(x){all(!is.na(x))})
X <- dat[,c(8, 4, 12)]
apply(X, 1, function(x){all(!is.na(x))})
X
str(X)
str(X2)
apply(X, 1, function(x){all(!is.na(x))})
apply(X2, 1, function(x){all(!is.na(x))})
length(apply(X2, 1, function(x){all(!is.na(x))}))
length(apply(X2, 1, function(x){all(!is.na(x))}))
length(apply(X, 1, function(x){all(!is.na(x))}))
X
nrow(X)
sum(unlist(lapply(as.data.frame(X), is.na)))
sum(unlist(lapply(as.data.frame(X2), is.na)))
### Remove rows containing NAs:
X <- X[noNaSel,]
X
### Remove rows containing NAs:
X2 <- X2[noNaSel,]
X2
X2 <- dat[dat$gender==0,c(8, 4, 12)]
X2 <- X2[apply(X, 1, function(x){all(!is.na(x))}),]
X2
X2 <- dat[dat$gender==0,c(8, 4, 12)]
X2 <- X2[apply(X2, 1, function(x){all(!is.na(x))}),]
X2
X
catVar <- dat$gender
catVar[noNaSel]
data.frame(X, catVar[noNaSel])
x <- X[,1]
y <- X[,2]
z <- X[,3]
### Generate (empty) 3D coordinate system:
### Set axis-length:
if(is.null(axesLeng)){
axesLeng <- max(X[,unlist(lapply(as.data.frame(X), is.numeric))], na.rm = TRUE)*1.5
}
### Plot empty coordinate system:
.coorSystem3D(axesNames, gridCol, axesLeng, axesTicks, zoom)
### Function to plot empty 3d coordinate system (only intended to be used inside nice3DPlot):
.coorSystem3D <- function(axesNames, gridCol, axesLeng, axesTicks, zoom) {
rgl::rgl.clear()
rgl::rgl.bg(color = 'white')
rgl::rgl.lines(c(0, axesLeng), c(0, 0), c(0, 0), color = "black")
rgl::rgl.lines(c(0, 0), c(0,axesLeng), c(0, 0), color = "black")
rgl::rgl.lines(c(0, 0), c(0, 0), c(0,axesLeng), color = "black")
axes <- rbind(c(axesLeng, 0, 0), c(0, axesLeng, 0),
c(0, 0, axesLeng))
rgl::rgl.texts(axes, text = axesNames[1:3], color='black', adj = c(0.5, -0.8))
if(axesTicks){
rgl::axis3d(edge = 'x', pos = c(NA,0,0), color='black')
rgl::axis3d(edge = 'y', pos = c(0,NA,0), color='black')
rgl::axis3d(edge = 'z', pos = c(0,0,NA), color='black')
}
rgl::rgl.viewpoint(theta = -120, phi = 0, zoom=zoom)
# grid on floor
x <- seq(0,axesLeng, length.out = 10)
z <- seq(0,axesLeng,length.out = 10)
y <- matrix(rep(0, 100), ncol = 10)
rgl::rgl.surface(x, z, y,
color = gridCol,
alpha = 0.5, lit = FALSE,front = "lines", back = "lines")
}
### Plot empty coordinate system:
.coorSystem3D(axesNames, gridCol, axesLeng, axesTicks, zoom)
### Apply the kernel density estimator:
dens <-  misc3d::kde3d(x,y,z, h = h, n = gridRes)
### Create the matrix needed for the rgl.points (this is simply a rearrangement to get everything in one table)
indices <- expand.grid(1:gridRes, 1:gridRes, 1:gridRes)
colnames(indices) <- c('x', 'y', 'z')
den_coor <- expand.grid(dens$x, dens$y, dens$z)
colnames(den_coor) <- c('x', 'y', 'z')
convertFunc <- function(x, dat){dat[x[1], x[2], x[3]]}
den_coor$dens <-  apply(indices, 1, convertFunc, dat=dens$d)
### Colour palette:
rbPal <- grDevices::colorRampPalette(c('blue', 'red'))
den_coor$col <- rbPal(colres)[as.numeric(cut(den_coor$dens,breaks = colres))]   # Here the progression of the colour pallette is defined
### Plot the points and or density:
stopifnot(whatToPlot[1] %in% c('P','D', 'PD'))
!is.null(catVar)
stopifnot(is.factor(catVar))
catVar
catVar <- as.factor(dat$gender)
catVar <- catVar[noNaSel]
catVar
data.frame(X, catVar[noNaSel])
noNaSel
head(dat)
X
X <- dat[,c(8,4,12)]
catVar <- as.factor(dat$gender)
dim(X)
length(catVar)
noNaSel <- apply(X, 1, function(x){all(!is.na(x))})
noNaSel
### Remove rows containing NAs:
X <- X[noNaSel,]
catVar[noNaSel]
catVar <-  catVar[noNaSel]
data.frame(X, catVar)
stopifnot(is.factor(catVar))
pointCol <- as.numeric(catVar)
pointCol
library(CustomFunctions)
library(CustomFunctions)
library(CustomFunctions)
library(CustomFunctions)
library(CustomFunctions)
library(CustomFunctions)
### Function to plot empty 3d coordinate system (only intended to be used inside nice3DPlot):
.coorSystem3D <- function(axesNames, gridCol, axesLeng, axesTicks, zoom) {
rgl::rgl.clear()
rgl::rgl.bg(color = 'white')
rgl::rgl.lines(c(0, axesLeng), c(0, 0), c(0, 0), color = "black")
rgl::rgl.lines(c(0, 0), c(0,axesLeng), c(0, 0), color = "black")
rgl::rgl.lines(c(0, 0), c(0, 0), c(0,axesLeng), color = "black")
axes <- rbind(c(axesLeng, 0, 0), c(0, axesLeng, 0),
c(0, 0, axesLeng))
rgl::rgl.texts(axes, text = axesNames[1:3], color='black', adj = c(0.5, -0.8))
if(axesTicks){
rgl::axis3d(edge = 'x', pos = c(NA,0,0), color='black')
rgl::axis3d(edge = 'y', pos = c(0,NA,0), color='black')
rgl::axis3d(edge = 'z', pos = c(0,0,NA), color='black')
}
rgl::rgl.viewpoint(theta = -120, phi = 0, zoom=zoom)
### grid on floor:
x <- seq(0,axesLeng, length.out = 10)
z <- seq(0,axesLeng,length.out = 10)
y <- matrix(rep(0, 100), ncol = 10)
rgl::rgl.surface(x, z, y,
color = gridCol,
alpha = 0.5, lit = FALSE,front = "lines", back = "lines")
}
.coorSystem3D()
?rep
rep(1, length.out=3)
rep(1:2, length.out=3)
rep(1:5, length.out=3)
source('~/Desktop/test.R')
nice3DPlot(iris)
nice3DPlot(iris[,2:4])
nice3DPlot(iris[,2:4], axesTicks = TRUE)
summary(iris)
nice3DPlot(iris[,2:4], axesTicks = TRUE, axesLeng = 5)
nice3DPlot(iris[,2:4], axesTicks = TRUE, axesLeng = c(5,1,5))
nice3DPlot(iris[,2:4], axesTicks = TRUE, axesLeng = c(1,5,5))
head(iris)
nice3DPlot(iris[,2:4], axesTicks = TRUE, axesLeng = c(5,5,1))
nice3DPlot(iris[,2:4], axesTicks = TRUE)
nice3DPlot(iris[,2:4], axesTicks = TRUE, zoom = 0.5)
nice3DPlot(iris[,2:4], axesTicks = TRUE, zoom = 0.1)
nice3DPlot(iris[,2:4], axesTicks = TRUE, zoom = 3)
nice3DPlot(iris[,2:4], axesTicks = TRUE, zoom = 2)
nice3DPlot(iris[,2:4], axesTicks = FALSE, zoom = 2)
nice3DPlot(iris[,2:4], axesTicks = FALSE, zoom = 1)
nice3DPlot(iris[,2:4], axesTicks = FALSE, zoom = 1.2)
nice3DPlot(iris[,2:4], axesTicks = FALSE, zoom = 1.2, catVar = iris$Species)
nice3DPlot(iris[,2:4], axesTicks = FALSE, zoom = 1.2, catVar = iris$Species, plotFit = 'lin')
nice3DPlot(iris[,2:4], axesTicks = FALSE, zoom = 1.2, catVar = iris$Species, plotFit = 'int')
nice3DPlot(iris[,2:4], axesTicks = FALSE, zoom = 1.2, catVar = iris$Species, plotFit = 'int2')
nice3DPlot(iris[,2:4], axesTicks = FALSE, zoom = 1.2, catVar = iris$Species, plotFit = 'int3')
nice3DPlot(iris[,2:4], axesTicks = FALSE, zoom = 1.2, plotFit = 'lin')
nice3DPlot(iris[,2:4], axesTicks = TRUE, zoom = 1.2, plotFit = 'lin')
library(CustomFunctions)
library(CustomFunctions)
